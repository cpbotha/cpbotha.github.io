<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Anonymous Functions on voices in my head</title><link>https://cpbotha.net/tags/anonymous-functions/</link><description>Recent content in Anonymous Functions on voices in my head</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 07 Jan 2016 20:01:00 +0000</lastBuildDate><atom:link href="https://cpbotha.net/tags/anonymous-functions/index.xml" rel="self" type="application/rss+xml"/><item><title>Closure expressions in Swift</title><link>https://cpbotha.net/2016/01/07/closure-expressions-in-swift/</link><pubDate>Thu, 07 Jan 2016 20:01:00 +0000</pubDate><guid>https://cpbotha.net/2016/01/07/closure-expressions-in-swift/</guid><description>Swift is a new high-performance compiled language designed by Apple. I’ve had some experience using it for an IOS development project, but the language is open source and is already available for Linux.
Some of you are probably able to appreciate the irony of me writing a blog post about Apple’s new programming language Swift, but here we are. :) I am, grudgingly, really impressed by Apple’s good work.
In this post I’m going to chat about closure expression syntax, in the process showing you IBM’s Swift Sandbox, an online tool for experimenting with Swift.</description><content:encoded><![CDATA[ <p><a href="https://swift.org/">Swift</a> is a new high-performance compiled language designed by Apple. I’ve had some experience using it for an IOS development project, but the language is open source and is already available for Linux.</p>
<p>Some of you are probably able to appreciate the irony of me writing a blog post about Apple’s new programming language Swift, but here we are. :) I am, grudgingly, really impressed by Apple’s good work.</p>
<p>In this post I’m going to chat about <em>closure expression syntax</em>, in the process showing you IBM’s Swift Sandbox, an online tool for experimenting with Swift.</p>
<p>Let’s start with a simple example (slightly modified from <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID95">Apple’s documentation on Swift closures</a>) for sorting a list of strings in reverse alphabetical order:</p>
<div class="org-src-container">
<pre class="src src-swift"><span style="color: #7F9F7F;">// names will be constaint, so we use let and not var</span>
<span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #DFAF8F;">names </span>= [<span style="color: #CC9393;">"Chris"</span>, <span style="color: #CC9393;">"Alex"</span>, <span style="color: #CC9393;">"Ewa"</span>, <span style="color: #CC9393;">"Barry"</span>, <span style="color: #CC9393;">"Daniella"</span>]
<p><span style="color: #7F9F7F;">// function taking two parameters and returning boolean</span>
<span style="color: #F0DFAF; font-weight: bold;">func</span> <span style="color: #93E0E3;">backwards</span>(s1: <span style="color: #7CB8BB;">String</span>, <span style="color: #F0DFAF; font-weight: bold;">_</span> s2: <span style="color: #7CB8BB;">String</span>) -&gt; <span style="color: #7CB8BB;">Bool</span> {
<span style="color: #F0DFAF; font-weight: bold;">return</span> s1 &gt; s2
}</p>
<p><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #DFAF8F;">reversed </span>= names.sort(backwards)</p>
<p>print(<span style="color: #CC9393;">&ldquo;Reversed alpha:&quot;</span>, reversed)
</pre></p>
</div>
<p>That’s a complete compilable program in Swift, which you can run directly in your browser by clicking <a href="http://swiftlang.ng.bluemix.net/#/repl/6ab18271be682adc2a39c45988978ee92826c41faf70ed4420664fce1cd42bc8">here</a>.</p>
<p>We use <code>let</code> to define a list of strings. Swift is strongly-typed, but in this case it simply infers the type of the <code>names</code> variable from the value that’s assigned to it. MAGIC!</p>
<p>If we were planning to change the value of the <code>names</code> list at some point, we would have had to use <code>var</code> (mutable) instead of <code>let</code> (immutable).</p>
<p>We then define a function called <code>backwards</code> that takes two strings, and returns the true value if the first is larger than the second. In the final let statement, we call the <code>sort()</code> method on the names list, but we pass it the <code>backwards()</code> function, which it will use to compare elements during sorting. Because we have flipped the <code>s1</code> and <code>s2</code> variables, we get our list back in reverse alphabetical order.</p>
<p><code>sort()</code> can be seen as a higher order function that takes the <code>backwards()</code> function as one of its inputs, and uses it to do its work.</p>
<p>Since we’re only using the <code>backwards()</code> function once, it would have been pretty convenient if there were some way to define it more compactly and in-place.</p>
<p>This is exactly what Swift’s <code>closure expression syntax</code> is for. Here’s the above code, with the <code>backwards()</code> function written as a closure expression:</p>
<div class="org-src-container">
<pre class="src src-swift"><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #DFAF8F;">names </span>= [<span style="color: #CC9393;">"Chris"</span>, <span style="color: #CC9393;">"Alex"</span>, <span style="color: #CC9393;">"Ewa"</span>, <span style="color: #CC9393;">"Barry"</span>, <span style="color: #CC9393;">"Daniella"</span>]
<p><span style="color: #7F9F7F;">// closure expression syntax for inline anonymous function:</span>
<span style="color: #7F9F7F;">// { (args) -&gt; returnType in statements }</span>
<span style="color: #F0DFAF; font-weight: bold;">var</span> <span style="color: #DFAF8F;">reversed </span>= names.sort({ (s1: <span style="color: #7CB8BB;">String</span>, s2: <span style="color: #7CB8BB;">String</span>) -&gt; <span style="color: #7CB8BB;">Bool</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #F0DFAF; font-weight: bold;">return</span> s1 &gt; s2})</p>
<p>print(<span style="color: #CC9393;">&ldquo;Reversed:&quot;</span>, reversed)
</pre></p>
</div>
<p>(You can run this Swift code in your browser by clicking <a href="http://swiftlang.ng.bluemix.net/#/repl/0dbcdef74dfef00da5c7f21878cb5ed42739796116a6fd232ab20f05d6040a81">here</a>.)</p>
<p>Instead of having to define and name a separate function, we can specify a function in the exact spot where it’s needed, using <em>closure expression syntax</em> i.e.: <code>{ (parameters) -&gt; returnType in statements }</code>.</p>
<p>For you Python-heads out there (MY PEOPLE!), the above code can be written in Python as follows:</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">names</span> = [<span style="color: #CC9393;">"Chris"</span>, <span style="color: #CC9393;">"Alex"</span>, <span style="color: #CC9393;">"Ewa"</span>, <span style="color: #CC9393;">"Barry"</span>, <span style="color: #CC9393;">"Daniella"</span>]
<p><span style="color: #DCDCCC; font-weight: bold;">reversed</span> = <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   names,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; font-weight: bold;">cmp</span>=<span style="color: #F0DFAF; font-weight: bold;">lambda</span> s1, s2: 0 <span style="color: #F0DFAF; font-weight: bold;">if</span> s1 == s2 <span style="color: #F0DFAF; font-weight: bold;">else</span> (-1 <span style="color: #F0DFAF; font-weight: bold;">if</span> s1 &gt; s2 <span style="color: #F0DFAF; font-weight: bold;">else</span> 1))</p>
<p><span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">reversed</span>)
</pre></p>
</div>
<p>In Python, <code>lambda</code> is used to specify anonymous function objects (our closure expression syntax, in other words). The compare function is defined differently, which is why it’s somewhat more complicated, but the principle is the same.</p>
<p>Whilst typing this blog, I downloaded Swift 2.2 from the <a href="https://swift.org/download/#latest-development-snapshots">open source download site</a> and installed it on my Ubuntu 14.04 laptop (the internet is so slow over here, we have to multi-task to stay sane). After compiling both the examples using <code>swiftc whatever.swift</code>, the resulting binaries are about 21 Kbytes each (they are dynamically linked to a number of system libraries, and the 5M <code>libswiftCore.so</code>).</p>










<figure><a href="/wp-content/uploads/2016/01/swift-sort-binaries.png">
    <img
        
            
            src="/wp-content/uploads/2016/01/swift-sort-binaries.png"
        /> </a>
</figure>

<p>The Swift language is open source, is already available for Linux, has a number of really compelling modern language features of which closure expressions are just one example (other interesting examples include optional types and protocol extensions), is statically typed with good type inference, and has a good compiler. For these reasons, it should be strongly considered for a permanent spot in your compiled language toolbox!</p>
<p>P.S. Yes, I do know that C++ has <code>lambda</code> and <code>auto</code>. I like them too!</p>
 ]]></content:encoded></item></channel></rss>